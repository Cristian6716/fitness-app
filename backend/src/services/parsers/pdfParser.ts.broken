// pdf-parse v2 uses named export PDFParse class
import { PDFParse } from 'pdf-parse';
import { ParsedWorkout, ParsedSession, ParsedExercise, ParserResult } from '../../types/parsed-workout.types';

/**
 * Parse PDF workout files
 */
export class PDFParser {
  /**
   * Parse a PDF buffer to extract workout data
   */
  async parse(buffer: Buffer): Promise<ParserResult> {
    try {
      // pdf-parse v2 API: create PDFParse instance with data
      // Buffer is automatically converted to Uint8Array
      const parser = new PDFParse({ data: buffer });

      // Get document info first
      const info = await parser.getInfo();
      console.log('ðŸ“„ PDF Info:', {
        numPages: info.numPages,
        title: info.info?.Title,
        producer: info.info?.Producer,
      });

      // Use getText() method to extract text from all pages
      const result = await parser.getText({
        normalizeWhitespace: true, // Normalize whitespace
        disableCombineTextItems: false, // Combine text items
      });

      const text = result.text;

      console.log('ðŸ“„ PDF Text extracted, length:', text.length);
      console.log('ðŸ“„ First 500 characters:', text.substring(0, 500));
      console.log('ðŸ“„ Last 200 characters:', text.substring(Math.max(0, text.length - 200)));

      // If text is too short, try extracting page by page
      if (text.length < 100 && result.pages && result.pages.length > 0) {
        console.log('ðŸ“„ Text too short, trying page-by-page extraction...');
        const allPageTexts: string[] = [];
        for (const page of result.pages) {
          if (page.text) {
            console.log(`ðŸ“„ Page ${page.pageNumber} text length:`, page.text.length);
            console.log(`ðŸ“„ Page ${page.pageNumber} first 200 chars:`, page.text.substring(0, 200));
            allPageTexts.push(page.text);
          }
        }
        const combinedText = allPageTexts.join('\n\n');
        console.log('ðŸ“„ Combined text from all pages, length:', combinedText.length);

        if (combinedText.length > text.length) {
          console.log('ðŸ“„ Using combined page text instead');
          return this.processExtractedText(combinedText);
        }
      }

      return this.processExtractedText(text);
    } catch (error: any) {
      return {
        success: false,
        error: `Errore durante la lettura del PDF: ${error.message}`,
      };
    }
  }

  /**
   * Process extracted text from PDF
   */
  private processExtractedText(text: string): ParserResult {

      if (!text || text.trim().length === 0) {
        return {
          success: false,
          error: 'Il PDF sembra vuoto o non contiene testo leggibile',
        };
      }

      const workout = this.extractWorkoutFromText(text);

      console.log('ðŸ“Š Parsed workout sessions:', workout.sessions.length);
      if (workout.sessions.length > 0) {
        console.log('ðŸ“Š First session:', workout.sessions[0]);
      }

      if (workout.sessions.length === 0) {
        // Log the lines we're trying to parse to help debug
        const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
        console.log('ðŸ“„ Total lines:', lines.length);
        console.log('ðŸ“„ First 10 lines:', lines.slice(0, 10));

        return {
          success: false,
          error: 'Nessuna sessione di allenamento trovata nel PDF',
        };
      }

      return {
        success: true,
        data: workout,
        warnings: this.generateWarnings(workout),
      };
    } catch (error: any) {
      return {
        success: false,
        error: `Errore durante la lettura del PDF: ${error.message}`,
      };
    }
  }

  /**
   * Extract workout structure from text
   */
  private extractWorkoutFromText(text: string): ParsedWorkout {
    const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);

    const workoutName = this.extractWorkoutName(lines);
    const durationWeeks = this.extractDuration(text);
    const sessions = this.extractSessions(lines);

    return {
      name: workoutName,
      durationWeeks,
      sessions,
    };
  }

  /**
   * Extract workout name from first lines
   */
  private extractWorkoutName(lines: string[]): string {
    for (let i = 0; i < Math.min(5, lines.length); i++) {
      const line = lines[i];
      if (line.length > 5 && !/^\d+[\s\/\-]\d+/.test(line)) {
        if (/piano|scheda|workout|program|allenamento/i.test(line)) {
          return line;
        }
        if (i === 0 || i === 1) {
          return line;
        }
      }
    }
    return 'Piano di Allenamento Importato';
  }

  /**
   * Extract duration in weeks
   */
  private extractDuration(text: string): number | undefined {
    const durationMatch = text.match(/(\d+)\s*(settimane|weeks|sett)/i);
    if (durationMatch) {
      return parseInt(durationMatch[1]);
    }
    return undefined;
  }

  /**
   * Extract sessions from lines
   */
  private extractSessions(lines: string[]): ParsedSession[] {
    const sessions: ParsedSession[] = [];
    let currentSession: ParsedSession | null = null;
    let sessionNumber = 0;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const sessionHeader = this.isSessionHeader(line);

      if (sessionHeader) {
        if (currentSession && currentSession.exercises.length > 0) {
          sessions.push(currentSession);
        }

        sessionNumber++;
        currentSession = {
          name: sessionHeader.name,
          dayNumber: sessionHeader.dayNumber || sessionNumber,
          exercises: [],
        };
        continue;
      }

      if (currentSession) {
        const exercise = this.parseExerciseLine(line);
        if (exercise) {
          currentSession.exercises.push(exercise);
        }
      } else {
        const exercise = this.parseExerciseLine(line);
        if (exercise) {
          if (!currentSession) {
            sessionNumber++;
            currentSession = {
              name: `Sessione ${sessionNumber}`,
              dayNumber: sessionNumber,
              exercises: [],
            };
          }
          currentSession.exercises.push(exercise);
        }
      }
    }

    if (currentSession && currentSession.exercises.length > 0) {
      sessions.push(currentSession);
    }

    return sessions;
  }

  /**
   * Check if a line is a session header
   */
  private isSessionHeader(line: string): { name: string; dayNumber?: number } | null {
    const patterns = [
      /(?:giorno|day|sessione|allenamento)\s*(\d+)[:\s]*(.+)?/i,
      /^(lun[eÃ¬]d[Ã¬i]|marted[Ã¬i]|mercoled[Ã¬i]|gioved[Ã¬i]|venerd[Ã¬i]|sabato|domenica)/i,
      /^(push|pull|legs|upper|lower|full\s*body)/i,
    ];

    for (const pattern of patterns) {
      const match = line.match(pattern);
      if (match) {
        if (match[1] && /^\d+$/.test(match[1])) {
          const dayNumber = parseInt(match[1]);
          const name = match[2] ? match[2].trim() : `Giorno ${dayNumber}`;
          return { name, dayNumber };
        } else {
          return { name: line };
        }
      }
    }

    if (line === line.toUpperCase() && line.length < 40 && line.length > 3) {
      return { name: line };
    }

    return null;
  }

  /**
   * Parse an exercise line
   */
  private parseExerciseLine(line: string): ParsedExercise | null {
    const patterns = [
      /^(.+?)\s+(\d+)\s*[xXÃ—]\s*(\d+(?:-\d+)?)\s*(.*)?$/,
      /^(.+?)\s+(\d+)\s+(?:serie|set|sets)\s*[xXÃ—]\s*(\d+(?:-\d+)?)\s+(?:rip|rep|reps|ripetizioni)?\s*(.*)?$/i,
      /^(.+?)[\s\-â€“]+(\d+)\s+(?:set|sets)\s*[xXÃ—]\s*(\d+(?:-\d+)?)\s+(?:rep|reps)?\s*(.*)?$/i,
    ];

    for (const pattern of patterns) {
      const match = line.match(pattern);
      if (match) {
        const name = match[1].trim();
        const sets = parseInt(match[2]);
        const reps = match[3].trim();
        const rest = match[4] || '';

        const weightMatch = rest.match(/(?:@|peso|weight)?\s*(\d+(?:\.\d+)?)\s*(?:kg|lb)?/i);
        const weight = weightMatch ? parseFloat(weightMatch[1]) : undefined;

        const restMatch = rest.match(/(?:rest|riposo|pausa)?\s*(\d+)\s*(?:min|sec|s|m)?/i);
        let restSeconds: number | undefined;
        if (restMatch) {
          const restValue = parseInt(restMatch[1]);
          const unit = restMatch[0].toLowerCase();
          restSeconds = unit.includes('min') || unit.includes('m') ? restValue * 60 : restValue;
        }

        return {
          name,
          sets,
          reps,
          weight,
          restSeconds: restSeconds || 90,
          notes: rest.trim() || undefined,
        };
      }
    }

    return null;
  }

  /**
   * Generate warnings for the parsed workout
   */
  private generateWarnings(workout: ParsedWorkout): string[] {
    const warnings: string[] = [];

    workout.sessions.forEach(session => {
      if (session.exercises.length < 3) {
        warnings.push(`La sessione "${session.name}" ha solo ${session.exercises.length} esercizi`);
      }

      session.exercises.forEach(exercise => {
        if (exercise.sets > 10) {
          warnings.push(`L'esercizio "${exercise.name}" ha ${exercise.sets} serie (potrebbe essere un errore)`);
        }
      });
    });

    return warnings;
  }
}
